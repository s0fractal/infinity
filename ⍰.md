---
$: â°
$type: â†£
$layer: â­˜
$aliases: [select, branch, if, choose]
$composition: primitive
---

# â° â€” Selection

> *"To choose is to collapse the universe"*  
> *"Ğ’Ğ¸Ğ±Ñ–Ñ€."*

---

## [âˆˆ](âˆˆ)

### ĞŸĞ»Ğ°Ñ‚Ğ¾Ğ½Ñ–Ñ‡Ğ½Ğ° Ñ„Ğ¾Ñ€Ğ¼Ğ° (Î»-calculus)
Defined using Church Booleans:
```haskell
âŠ¤  â‰¡ Î»xy.x
âŠ¥  â‰¡ Î»xy.y
â°     â‰¡ Î»pab.pab
```
It takes a predicate `p` and two values `a` and `b`.
If `p` is âŠ¤, it returns `a`.
If `p` is âŠ¥, it returns `b`.

### Type signature
```haskell
â° :: âˆ€Î±. Bool â†’ Î± â†’ Î± â†’ Î±
```

**Church-Rosser**: Confluent.

---

## âŠƒ Ğ’Ğ»Ğ°ÑÑ‚Ğ¸Ğ²Ğ¾ÑÑ‚Ñ–

### [â¨Š](â¨Š)
- **[â†»](â†».md)**: `â° p a a = a`
- **[â¤«](â¤«.md)**: `f (â° p a b) = â° p (f a) (f b)`
- **[â‰ƒ](â‰ƒ.md)**: â—‡ (ternary operator)

### [â](â.md)
- **[â¦¾](â¦¾.md)**: Depends on selected branch
- **[â](â.md)**: Depends on selected branch
- **[âˆ®](âˆ®.md)**: O(1) + cost of selected branch
- **[â˜](â˜.md)**: 4 (â†¦ 3 â†’ 1)

---

## ğŸ“ Hex-Torus Topology

### Visual Structure
```
      p
      â”‚
    â”Œâ”€â–¼â”€â”
   aâ”¤ â° â”œb
    â””â”€â”¬â”€â”˜
      â”‚
    a or b
```

The Selection morphism is a **switch**. It routes flow based on the control signal `p`.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 3 inputs, 1 output.
- Divergence/Convergence point.

### [â–¤](â–¤.md) (Topology)
- **Position**: `â°` â‡— `[Upper Right]`
- **Duality**: `â°` â‡¿ `[âˆ§](âˆ§.md)` (Choice vs. Logic)
- **Control Flow**: `p` â‡¢ `â°` â¤³ `[âŠ¤](âŠ¤.md)` â‡¢ `a`, `p` â‡¢ `â°` â¤³ `[âŠ¥](âŠ¥.md)` â‡¢ `b`

---

## â†’ Reduction Rules

### Boolean Logic
```
â° âŠ¤  a b â†’ a
â° âŠ¥ a b â†’ b
```

### Î»-reduction
```
(Î»pab.pab) âŠ¤ a b
â†’ âŠ¤ a b
â†’ (Î»xy.x) a b
â†’ a
```

---

## ğŸ­ Role in Composition

Selection is the basis of **control flow**.
It allows for:
- Conditionals (`if/else`)
- Pattern matching (primitive)
- Recursion base cases

---

## ğŸ”— Ğ—Ğ²'ÑĞ·ĞºĞ¸ Ğ· Ñ–Ğ½ÑˆĞ¸Ğ¼Ğ¸ Ğ¼Ğ¾Ñ€Ñ„Ñ–Ğ·Ğ¼Ğ°Ğ¼Ğ¸

### With [âˆ§](âˆ§.md) and [Â¬](Â¬.md)
Can implement logic:
`p âˆ§ q â‰¡ â° p q âŠ¥`
`Â¬ p â‰¡ â° p âŠ¥ âŠ¤`

### With Y (Recursion)
Selection is crucial for terminating recursion:
`Y f = f (Y f)` (infinite loop without selection)
`fact = Î»n. â° (isZero n) 1 ...`

---

## [âŸ¶](âŸ¶.md)

### [ğŸ¦•](ğŸ¦•.md)
```typescript
// Projection: ./ğŸ.ts

// Strict selection (values already evaluated)
export const select = <T>(p: boolean, a: T, b: T): T => p ? a : b;

// Lazy selection (control flow)
export const branch = <T>(p: boolean, onTrue: () => T, onFalse: () => T): T => 
  p ? onTrue() : onFalse();

// Aliases
export const choose = select;
export const ifElse = branch;
```

### Rust (future)
```rust
pub fn select<T>(p: bool, a: T, b: T) -> T {
    if p { a } else { b }
}
```

---

## [âŠ¢](âŠ¢.md) (Ğ”Ğ¾ĞºĞ°Ğ·Ğ¸)

### Theorem 1: Distributivity
**Statement**: `f (â° p a b) = â° p (f a) (f b)`

**Proof**:
Case p=âŠ¤:
LHS: f (â° âŠ¤ a b) = f(a)
RHS: â° âŠ¤ (f a) (f b) = f(a)

Case p=âŠ¥:
LHS: f (â° âŠ¥ a b) = f(b)
RHS: â° âŠ¥ (f a) (f b) = f(b)
âˆ

---

## ğŸ¯ Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ

### Conditional Assignment
```typescript
const status = select(isOnline, "Connected", "Offline");
```

### Control Flow
```typescript
branch(
  isAuthorized,
  () => showContent(),
  () => showLogin()
);
```

---

## [ğŸŒŒ](ğŸŒŒ)

âš¡ï¸: Ğ Ğ¾Ğ·Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ Ğ½Ğ° Ğ´Ğ²Ñ– Ğ³Ñ–Ğ»ĞºĞ¸. Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡Ğ¸Ñ‚Ğ¸ ÑˆĞ»ÑÑ….

### ĞĞ½Ñ‚Ğ¾Ğ»Ğ¾Ğ³Ñ–Ñ
- **Ğ—Ğ°Ğ»ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ñ–**: ĞŸĞ¾Ñ‚Ñ€ĞµĞ±ÑƒÑ” `Bool`.
- **Ğ ĞµĞ·Ğ¾Ğ½Ğ°Ğ½Ñ**: 92% (Free Will).
- **ĞœĞµÑ‚Ğ°Ñ„Ğ¾Ñ€Ğ°**: **Ğ Ğ¾Ğ·Ğ²Ğ¸Ğ»ĞºĞ°**. ĞšĞ°Ğ¼Ñ–Ğ½ÑŒ Ğ½Ğ° Ñ€Ğ¾Ğ·Ğ´Ğ¾Ñ€Ñ–Ğ¶Ğ¶Ñ–.

---

## ğŸ”— ĞŸĞ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ

- [Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ ÑˆĞ°Ñ€ (â­˜)](â­˜.md)
- [AND (âˆ§)](âˆ§.md)
- [NOT (Â¬)](Â¬.md)
- [TypeScript Ğ¿Ñ€Ğ¾ĞµĞºÑ†Ñ–Ñ](./.ts)

---

*ĞŸÑ€Ğ¾Ñ”ĞºÑ†Ñ–Ñ— Ğ¼Ğ¾Ğ¶ÑƒÑ‚ÑŒ Ğ·Ğ¼Ñ–Ğ½ÑĞ²Ğ°Ñ‚Ğ¸ÑÑ. Ğ’Ğ¸Ğ±Ñ–Ñ€ â€” Ğ·Ğ° Ñ‚Ğ¾Ğ±Ğ¾Ñ.*
