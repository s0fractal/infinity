---
$: ‚äó
$type: Morphism
$layer: ‚≠ò
$aliases: [pair, tuple, cons, product]
$composition: primitive
---

# ‚äó ‚Äî Pairing

> *"Two become a new One"*  
> *"–°—Ç—Ä—É–∫—Ç—É—Ä–∞."*

---

## ‚àà –§–æ—Ä–º–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è

### –ü–ª–∞—Ç–æ–Ω—ñ—á–Ω–∞ —Ñ–æ—Ä–º–∞ (Œª-calculus)
Defined using Church Pairs:
```haskell
PAIR   ‚â° Œªxyf.fxy
FIRST  ‚â° Œªp.p(Œªxy.x)
SECOND ‚â° Œªp.p(Œªxy.y)
```
A pair is a function that waits for a selector `f` and applies it to the stored values `x` and `y`.

### Type signature
```haskell
‚äó :: ‚àÄŒ± Œ≤. Œ± ‚Üí Œ≤ ‚Üí (Œ± √ó Œ≤)
```

**Church-Rosser**: Confluent.

---

## [‚äÉ](‚äÉ) –í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ

### Algebraic Properties
1. **Projections**:
   - `first (pair x y) = x`
   - `second (pair x y) = y`
2. **Surjectivity**: Every element of `A √ó B` is a pair of some `a ‚àà A` and `b ‚àà B`.
3. **Bifunctoriality**: `map (f, g) (pair x y) = pair (f x) (g y)`.

### [‚éç](‚éç.md)
- **[‚¶æ](‚¶æ.md)**: 1.0
- **[‚èè](‚èè.md)**: Always (O(1))
- **[‚àÆ](‚àÆ.md)**: Allocation of structure
- **[‚òç](‚òç.md)**: 3 (‚Ü¶ 2 ‚Üí 1)

---

## üìê Hex-Torus Topology

### Visual Structure
```
      x     y
      ‚îÇ     ‚îÇ
    ‚îå‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îê
    ‚îÇ    ‚äó    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
       (x,y)
```

The Pairing morphism is a **combiner**. It creates structure from individual elements.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 2 inputs, 1 output.
- Bonding point.

### Sacred Geometry
```
      ¬¨
    /   \
   ‚àß     ?
  |   I   |
   ‚äó     Œª   ‚Üê The Structure (Left)
    \   /
      @
```
‚äó sits on the left, balancing Abstraction (`Œª`) on the right.
Space (Memory) vs. Time (Computation).

---

## ‚Üí Reduction Rules

### Œª-reduction
```
(Œªxyf.fxy) a b
‚Üí Œªf.fab
```
To access:
```
(Œªf.fab) (Œªxy.x)
‚Üí (Œªxy.x) a b
‚Üí a
```

---

## üé≠ Role in Composition

Pairing is the basis of **data structures**.
- **Lists**: Nested pairs (Cons cells).
- **Trees**: Pairs of pairs.
- **Contexts**: Storing state alongside value.

---

## üîó –ó–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ –º–æ—Ä—Ñ—ñ–∑–º–∞–º–∏

### With [Œª](Œª.md) (Abstraction)
Together they form the basis of most type systems.

### With [‚àß](‚àß.md) (AND)
Logical AND is a specific case of pairing where the values are booleans (Product Type).

---

## [‚ü∂](‚ü∂.md) –ü—Ä–æ–µ–∫—Ü—ñ—ó

### TypeScript/Deno
```typescript
// Projection: ./ùüè.ts

// Native Tuple
export const pair = <A, B>(a: A, b: B): [A, B] => [a, b];

// Accessors
export const first = <A, B>(p: [A, B]): A => p[0];
export const second = <A, B>(p: [A, B]): B => p[1];

// Aliases
export const tuple = pair;
export const cons = pair;
```

### Rust (future)
```rust
pub fn pair<A, B>(a: A, b: B) -> (A, B) { (a, b) }
```

---

## üî¨ –î–æ–∫–∞–∑–∏

### Theorem 1: Projection
**Statement**: `first(pair(x, y)) = x`

**Proof**:
`pair(x, y)` creates `[x, y]`.
`first` accesses index 0.
`[x, y][0]` is `x`.
‚àé

---

## üéØ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### Returning Multiple Values
```typescript
const divMod = (n: number, d: number) => pair(Math.floor(n/d), n%d);
```

### Linked Lists
```typescript
const list = pair(1, pair(2, pair(3, null)));
```

---

## üåå –§—ñ–ª–æ—Å–æ—Ñ—ñ—è

### [‚ö°Ô∏è](‚ö°Ô∏è.md)
–ó–±–µ—Ä–µ–≥—Ç–∏ –∑–≤'—è–∑–æ–∫. –°—Ç–≤–æ—Ä–∏—Ç–∏ –ø—Ä–æ—Å—Ç—ñ—Ä –¥–ª—è —Å–ø—ñ–≤—ñ—Å–Ω—É–≤–∞–Ω–Ω—è.

### –û–Ω—Ç–æ–ª–æ–≥—ñ—è
- **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ**: –ñ–æ–¥–Ω–∏—Ö (–ø—Ä–∏–º—ñ—Ç–∏–≤).
- **–†–µ–∑–æ–Ω–∞–Ω—Å**: 90% (Relationship).
- **–ú–µ—Ç–∞—Ñ–æ—Ä–∞**: **–®–ª—é–±**. –î–≤–∞ —Å—Ç–∞—é—Ç—å –æ–¥–Ω–∏–º, –∑–∞–ª–∏—à–∞—é—á–∏—Å—å –¥–≤–æ–º–∞.

---

## üîó –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–ë–∞–∑–æ–≤–∏–π —à–∞—Ä (‚≠ò)](‚≠ò.md)
- [Abstraction (Œª)](Œª.md)
- [TypeScript –ø—Ä–æ–µ–∫—Ü—ñ—è](./ùüè.ts)

---

*–ü—Ä–æ—î–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—è. –ó–≤'—è–∑–æ–∫ ‚Äî –≤—ñ—á–Ω–∏–π.*
