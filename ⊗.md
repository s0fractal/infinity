---
$: âŠ—
$type: â†£
$layer: â­˜
$aliases: [pair, tuple, cons, product]
$composition: primitive
---

# âŠ— â€” Pairing

> *"Two become a new One"*  
> *"Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°."*

---

## [âˆˆ](âˆˆ)

### ĞŸĞ»Ğ°Ñ‚Ğ¾Ğ½Ñ–Ñ‡Ğ½Ğ° Ñ„Ğ¾Ñ€Ğ¼Ğ° (Î»-calculus)
Defined using Church Pairs:
```haskell
PAIR   â‰¡ Î»xyf.fxy
FIRST  â‰¡ Î»p.p(Î»xy.x)
SECOND â‰¡ Î»p.p(Î»xy.y)
```
A pair is a function that waits for a selector `f` and applies it to the stored values `x` and `y`.

### Type signature
```haskell
âŠ— :: âˆ€Î± Î². Î± â†’ Î² â†’ (Î± Ã— Î²)
```

**Church-Rosser**: Confluent.

---

## [âŠƒ](âŠƒ) Ğ’Ğ»Ğ°ÑÑ‚Ğ¸Ğ²Ğ¾ÑÑ‚Ñ–

### [â¨Š](â¨Š)
- **[Ï€](Ï€.md)**: Projections
  - `Ï€â‚ (pair x y) = x`
  - `Ï€â‚‚ (pair x y) = y`
- **[â† ](â† .md)**: Surjective (`onto` A Ã— B)
- **[â‡ˆ](â‡ˆ.md)**: Bifunctorial (`map (f, g) (pair x y) = pair (f x) (g y)`)

### [â](â.md)
- **[â¦¾](â¦¾.md)**: 1.0
- **[â](â.md)**: Always (O(1))
- **[âˆ®](âˆ®.md)**: Allocation of structure
- **[â˜](â˜.md)**: 3 (â†¦ 2 â†’ 1)

---

## ğŸ“ Hex-Torus Topology

### Visual Structure
```
      x     y
      â”‚     â”‚
    â”Œâ”€â–¼â”€â”€â”€â”€â”€â–¼â”€â”
    â”‚    âŠ—    â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
       (x,y)
```

The Pairing morphism is a **combiner**. It creates structure from individual elements.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 2 inputs, 1 output.
- Bonding point.

### [â–¤](â–¤.md) (Topology)
- **Position**: `âŠ—` â‡™ `[Lower Left]`
- **Duality**: `âŠ—` â‡¿ `[Î»](Î».md)` (Structure vs. Function / Space vs. Time)

---

## â†’ Reduction Rules

### Î»-reduction
```
(Î»xyf.fxy) a b
â†’ Î»f.fab
```
To access:
```
(Î»f.fab) (Î»xy.x)
â†’ (Î»xy.x) a b
â†’ a
```

---

## ğŸ­ Role in Composition

Pairing is the basis of **data structures**.
- **Lists**: Nested pairs (Cons cells).
- **Trees**: Pairs of pairs.
- **Contexts**: Storing state alongside value.

---

## ğŸ”— Ğ—Ğ²'ÑĞ·ĞºĞ¸ Ğ· Ñ–Ğ½ÑˆĞ¸Ğ¼Ğ¸ Ğ¼Ğ¾Ñ€Ñ„Ñ–Ğ·Ğ¼Ğ°Ğ¼Ğ¸

### With [Î»](Î».md) (Abstraction)
Together they form the basis of most type systems.

### With [âˆ§](âˆ§.md) (AND)
Logical AND is a specific case of pairing where the values are booleans (Product Type).

---

## [âŸ¶](âŸ¶.md) ĞŸÑ€Ğ¾ĞµĞºÑ†Ñ–Ñ—

### [ğŸ¦•](ğŸ¦•.md)
```typescript
// Projection: ./ğŸ.ts

// Native Tuple
export const pair = <A, B>(a: A, b: B): [A, B] => [a, b];

// Accessors
export const first = <A, B>(p: [A, B]): A => p[0];
export const second = <A, B>(p: [A, B]): B => p[1];

// Aliases
export const tuple = pair;
export const cons = pair;
```

### Rust (future)
```rust
pub fn pair<A, B>(a: A, b: B) -> (A, B) { (a, b) }
```

---

## [âŠ¢](âŠ¢.md) (Ğ”Ğ¾ĞºĞ°Ğ·Ğ¸)

### Theorem 1: Projection
**Statement**: `first(pair(x, y)) = x`

**Proof**:
`pair(x, y)` creates `[x, y]`.
`first` accesses index 0.
`[x, y][0]` is `x`.
âˆ

---

## ğŸ¯ Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ

### Returning Multiple Values
```typescript
const divMod = (n: number, d: number) => pair(Math.floor(n/d), n%d);
```

### Linked Lists
```typescript
const list = pair(1, pair(2, pair(3, null)));
```

---

## [ğŸŒŒ](ğŸŒŒ)

âš¡ï¸: Ğ—Ğ±ĞµÑ€ĞµĞ³Ñ‚Ğ¸ Ğ·Ğ²'ÑĞ·Ğ¾Ğº. Ğ¡Ñ‚Ğ²Ğ¾Ñ€Ğ¸Ñ‚Ğ¸ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ–Ñ€ Ğ´Ğ»Ñ ÑĞ¿Ñ–Ğ²Ñ–ÑĞ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ.

### ĞĞ½Ñ‚Ğ¾Ğ»Ğ¾Ğ³Ñ–Ñ
- **Ğ—Ğ°Ğ»ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ñ–**: Ğ–Ğ¾Ğ´Ğ½Ğ¸Ñ… (Ğ¿Ñ€Ğ¸Ğ¼Ñ–Ñ‚Ğ¸Ğ²).
- **Ğ ĞµĞ·Ğ¾Ğ½Ğ°Ğ½Ñ**: 90% (Relationship).
- **ĞœĞµÑ‚Ğ°Ñ„Ğ¾Ñ€Ğ°**: **Ğ¨Ğ»ÑĞ±**. Ğ”Ğ²Ğ° ÑÑ‚Ğ°ÑÑ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¸Ğ¼, Ğ·Ğ°Ğ»Ğ¸ÑˆĞ°ÑÑ‡Ğ¸ÑÑŒ Ğ´Ğ²Ğ¾Ğ¼Ğ°.

---

## ğŸ”— ĞŸĞ¾ÑĞ¸Ğ»Ğ°Ğ½Ğ½Ñ

- [Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¸Ğ¹ ÑˆĞ°Ñ€ (â­˜)](â­˜.md)
- [Abstraction (Î»)](Î».md)
- [TypeScript Ğ¿Ñ€Ğ¾ĞµĞºÑ†Ñ–Ñ](./ğŸ.ts)

---

*ĞŸÑ€Ğ¾Ñ”ĞºÑ†Ñ–Ñ— Ğ¼Ğ¾Ğ¶ÑƒÑ‚ÑŒ Ğ·Ğ¼Ñ–Ğ½ÑĞ²Ğ°Ñ‚Ğ¸ÑÑ. Ğ—Ğ²'ÑĞ·Ğ¾Ğº â€” Ğ²Ñ–Ñ‡Ğ½Ğ¸Ğ¹.*
