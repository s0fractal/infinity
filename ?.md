---
$: '?'
$type: Morphism
$layer: ‚≠ò
$aliases: [select, branch, if, choose]
$composition: primitive
---

# ? ‚Äî Selection

> *"To choose is to collapse the universe"*  
> *"–í–∏–±—ñ—Ä."*

---

## ‚àà –§–æ—Ä–º–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è

### –ü–ª–∞—Ç–æ–Ω—ñ—á–Ω–∞ —Ñ–æ—Ä–º–∞ (Œª-calculus)
Defined using Church Booleans:
```haskell
TRUE  ‚â° Œªxy.x
FALSE ‚â° Œªxy.y
?     ‚â° Œªpab.pab
```
It takes a predicate `p` and two values `a` and `b`.
If `p` is TRUE, it returns `a`.
If `p` is FALSE, it returns `b`.

### Type signature
```haskell
? :: ‚àÄŒ±. Bool ‚Üí Œ± ‚Üí Œ± ‚Üí Œ±
```

**Church-Rosser**: Confluent.

---

## ‚äÉ –í–ª–∞—Å—Ç–∏–≤–æ—Å—Ç—ñ

### [‚®ä](‚®ä)
- **[‚Üª](‚Üª.md)**: `? p a a = a`
- **[‚§´](‚§´.md)**: `f (? p a b) = ? p (f a) (f b)`
- **[‚âÉ](‚âÉ.md)**: ‚óá (ternary operator)

### [‚éç](‚éç.md)
- **[‚¶æ](‚¶æ.md)**: Depends on selected branch
- **[‚èè](‚èè.md)**: Depends on selected branch
- **[‚àÆ](‚àÆ.md)**: O(1) + cost of selected branch
- **[‚òç](‚òç.md)**: 4 (‚Ü¶ 3 ‚Üí 1)

---

## üìê Hex-Torus Topology

### Visual Structure
```
      p
      ‚îÇ
    ‚îå‚îÄ‚ñº‚îÄ‚îê
   a‚î§ ? ‚îúb
    ‚îî‚îÄ‚î¨‚îÄ‚îò
      ‚îÇ
    a or b
```

The Selection morphism is a **switch**. It routes flow based on the control signal `p`.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 3 inputs, 1 output.
- Divergence/Convergence point.

### Sacred Geometry
```
      ¬¨
    /   \
   ‚àß     ?   ‚Üê The Choice (Right)
  |   I   |
   ‚äó     Œª
    \   /
      @
```
? sits on the upper right, balancing Logic (`‚àß`) on the left.
Freedom vs. Constraint.

---

## ‚Üí Reduction Rules

### Boolean Logic
```
? TRUE  a b ‚Üí a
? FALSE a b ‚Üí b
```

### Œª-reduction
```
(Œªpab.pab) TRUE a b
‚Üí TRUE a b
‚Üí (Œªxy.x) a b
‚Üí a
```

---

## üé≠ Role in Composition

Selection is the basis of **control flow**.
It allows for:
- Conditionals (`if/else`)
- Pattern matching (primitive)
- Recursion base cases

---

## üîó –ó–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ –º–æ—Ä—Ñ—ñ–∑–º–∞–º–∏

### With ‚àß (AND) and ¬¨ (NOT)
Can implement logic:
`p ‚àß q ‚â° ? p q FALSE`
`¬¨ p ‚â° ? p FALSE TRUE`

### With Y (Recursion)
Selection is crucial for terminating recursion:
`Y f = f (Y f)` (infinite loop without selection)
`fact = Œªn. ? (isZero n) 1 ...`

---

## üìä –ü—Ä–æ–µ–∫—Ü—ñ—ó

### TypeScript/Deno
```typescript
// Projection: ./ùüè.ts

// Strict selection (values already evaluated)
export const select = <T>(p: boolean, a: T, b: T): T => p ? a : b;

// Lazy selection (control flow)
export const branch = <T>(p: boolean, onTrue: () => T, onFalse: () => T): T => 
  p ? onTrue() : onFalse();

// Aliases
export const choose = select;
export const ifElse = branch;
```

### Rust (future)
```rust
pub fn select<T>(p: bool, a: T, b: T) -> T {
    if p { a } else { b }
}
```

---

## üî¨ –î–æ–∫–∞–∑–∏

### Theorem 1: Distributivity
**Statement**: `f (? p a b) = ? p (f a) (f b)`

**Proof**:
Case p=TRUE:
LHS: f (? T a b) = f(a)
RHS: ? T (f a) (f b) = f(a)

Case p=FALSE:
LHS: f (? F a b) = f(b)
RHS: ? F (f a) (f b) = f(b)
‚àé

---

## üéØ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### Conditional Assignment
```typescript
const status = select(isOnline, "Connected", "Offline");
```

### Control Flow
```typescript
branch(
  isAuthorized,
  () => showContent(),
  () => showLogin()
);
```

---

## üåå –§—ñ–ª–æ—Å–æ—Ñ—ñ—è

### –Ü–Ω—Ç–µ–Ω—Ü—ñ—è
–†–æ–∑–¥—ñ–ª–∏—Ç–∏ —Ä–µ–∞–ª—å–Ω—ñ—Å—Ç—å –Ω–∞ –¥–≤—ñ –≥—ñ–ª–∫–∏.
–í–∏–∑–Ω–∞—á–∏—Ç–∏ —à–ª—è—Ö.

### –û–Ω—Ç–æ–ª–æ–≥—ñ—è
- **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ**: –ü–æ—Ç—Ä–µ–±—É—î `Bool`.
- **–†–µ–∑–æ–Ω–∞–Ω—Å**: 92% (Free Will).
- **–ú–µ—Ç–∞—Ñ–æ—Ä–∞**: **–†–æ–∑–≤–∏–ª–∫–∞**. –ö–∞–º—ñ–Ω—å –Ω–∞ —Ä–æ–∑–¥–æ—Ä—ñ–∂–∂—ñ.

---

## üîó –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–ë–∞–∑–æ–≤–∏–π —à–∞—Ä (‚≠ò)](‚≠ò.md)
- [AND (‚àß)](‚àß.md)
- [NOT (¬¨)](¬¨.md)
- [TypeScript –ø—Ä–æ–µ–∫—Ü—ñ—è](./.ts)

---

*–ü—Ä–æ—î–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—è. –í–∏–±—ñ—Ä ‚Äî –∑–∞ —Ç–æ–±–æ—é.*
