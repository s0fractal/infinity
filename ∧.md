---
$: ∧
$type: ↣
$layer: ⭘
$aliases: [and, conjunction, all, U+2227, AND, кон’юнкція, allOf ∩]
$composition: primitive
---

# ∧ — AND

> *"Two paths become one truth"*  
> *"Єдність."*

---

## [∈](∈)

### Платонічна форма (λ-calculus)
Defined using Church Booleans:
```haskell
⊤  ≡ λxy.x
⊥  ≡ λxy.y
∧     ≡ λpq.pqp
```
If `p` is ⊤, it returns `q` (so result depends on `q`).
If `p` is ⊥, it returns `p` (which is ⊥).

### Type signature
```haskell
∧ :: Bool → Bool → Bool
```

**Church-Rosser**: Confluent.

---

## [⊃](⊃)

### [⨊](⨊)
- **[≃](≃.md)**: `(a ∧ b) ∧ c = a ∧ (b ∧ c)`
- **[⇆](⇆.md)**: `a ∧ b = b ∧ a` (Commutative)
- **[↻](↻.md)**: `a ∧ a = a`
- **[◦](◦.md)**: `⊤` (Identity Element)
- **[⚫](⚫.md)**: `⊥` (Annihilator)
- **[⤫](⤫.md)**: Over `∨` (OR)

### [⎍](⎍.md)
- **[⦾](⦾.md)**: 1.0
- **[⏏](⏏.md)**: Always (O(1))
- **[∮](∮.md)**: O(1)
- **[☍](☍.md)**: 3 (↦ 2 → 1)

---

## 📐 Hex-Torus Topology

### Visual Structure
```
      p     q
      │     │
    ┌─▼─────▼─┐
    │    ∧    │
    └────┬────┘
         │
       p ∧ q
```

The AND morphism is a **gate**. It only allows flow if both conditions are met.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 2 inputs, 1 output.
- Convergence point.

### Sacred Geometry
```
      ¬
    /   \
   ∧     ?   ← Logic Gate (Left)
  |   I   |
   ⊗     λ
    \   /
      @
```
∧ sits on the upper left, balancing Selection (`?`) on the right.
Logic vs. Choice.

---

## → Reduction Rules

### Boolean Logic
```
⊤  ∧ ⊤  → ⊤
⊤  ∧ ⊥ → ⊥
⊥ ∧ ⊤  → ⊥
⊥ ∧ ⊥ → ⊥
```

### λ-reduction
```
(λpq.pqp) ⊤ ⊤
→ ⊤ ⊤ ⊤
→ (λxy.x) ⊤ ⊤
→ ⊤
```

---

## 🎭 Role in Composition

AND is the fundamental **aggregator** of truth.
It is used to combine predicates and conditions.

### Filter
Used in `filter` operations to combine multiple criteria.

---

## 🔗 Зв'язки з іншими ↣ами

### With ¬ (NOT)
De Morgan's Laws connect ∧ and ∨ (OR) via ¬.
`a ∧ b = ¬(¬a ∨ ¬b)`

### With ? (Selection)
AND can be implemented using Selection:
`p ∧ q ≡ ? p q ⊥`

---

## [⟶](⟶) Проекції

### [🦕](🦕)
```typescript
// Projection: ./𝟏.ts
export const and = (p: boolean, q: boolean): boolean => p && q;

// Curried version (optional)
export const andC = (p: boolean) => (q: boolean) => p && q;

// Aliases
export const conjunction = and;
export const all = and;
```

### Rust (future)
```rust
pub fn and(p: bool, q: bool) -> bool { p && q }
```

---

## 🔬 Докази

### Theorem 1: Commutativity
**Statement**: `p ∧ q = q ∧ p`

**Proof**:
By truth table:
⊤ ⊤ -> ⊤ = ⊤
⊤ ⊥ -> ⊥ = ⊥
⊥ ⊤ -> ⊥ = ⊥
⊥ ⊥ -> ⊥ = ⊥
∎

---

## 🎯 Використання

### Guard Clauses
```typescript
if (and(isValid, isReady)) {
  proceed();
}
```

### Validation
```typescript
const isValidUser = (u: User) => and(hasName(u), hasEmail(u));
```

---

## [🌌](🌌)

### [⚡️](⚡️)
Знайти перетин. Підтвердити спільну істину.

### Онтологія
- **Залежності**: Потребує `Bool` (який виводиться з `λ`).
- **Резонанс**: 85% (Logic).
- **Метафора**: **Вузол**. Місце, де дві нитки стають канатом.

---

## 🔗 Посилання

- [Базовий шар (⭘)](⭘)
- [NOT (¬)](¬)
- [Selection (?)](../?/𝟏.md)
- [TypeScript проекція](./𝟏.ts)

---

*Проєкції можуть змінюватися. Істина — одна.*

