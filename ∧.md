---
$: ‚àß
$type: ‚Ü£
$layer: ‚≠ò
$aliases: [and, conjunction, all, U+2227, AND, –∫–æ–Ω‚Äô—é–Ω–∫—Ü—ñ—è, allOf ‚à©]
$composition: primitive
---

# ‚àß ‚Äî AND

> *"Two paths become one truth"*  
> *"–Ñ–¥–Ω—ñ—Å—Ç—å."*

---

## [‚àà](‚àà)

### –ü–ª–∞—Ç–æ–Ω—ñ—á–Ω–∞ —Ñ–æ—Ä–º–∞ (Œª-calculus)
Defined using Church Booleans:
```haskell
‚ä§  ‚â° Œªxy.x
‚ä•  ‚â° Œªxy.y
‚àß     ‚â° Œªpq.pqp
```
If `p` is ‚ä§, it returns `q` (so result depends on `q`).
If `p` is ‚ä•, it returns `p` (which is ‚ä•).

### Type signature
```haskell
‚àß :: Bool ‚Üí Bool ‚Üí Bool
```

**Church-Rosser**: Confluent.

---

## [‚äÉ](‚äÉ)

### [‚®ä](‚®ä)
- **[‚âÉ](‚âÉ.md)**: `(a ‚àß b) ‚àß c = a ‚àß (b ‚àß c)`
- **[‚áÜ](‚áÜ.md)**: `a ‚àß b = b ‚àß a` (Commutative)
- **[‚Üª](‚Üª.md)**: `a ‚àß a = a`
- **[‚ó¶](‚ó¶.md)**: `‚ä§` (Identity Element)
- **[‚ö´](‚ö´.md)**: `‚ä•` (Annihilator)
- **[‚§´](‚§´.md)**: Over `‚à®` (OR)

### [‚éç](‚éç.md)
- **[‚¶æ](‚¶æ.md)**: 1.0
- **[‚èè](‚èè.md)**: Always (O(1))
- **[‚àÆ](‚àÆ.md)**: O(1)
- **[‚òç](‚òç.md)**: 3 (‚Ü¶ 2 ‚Üí 1)

---

## üìê Hex-Torus Topology

### Visual Structure
```
      p     q
      ‚îÇ     ‚îÇ
    ‚îå‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îê
    ‚îÇ    ‚àß    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
       p ‚àß q
```

The AND morphism is a **gate**. It only allows flow if both conditions are met.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 2 inputs, 1 output.
- Convergence point.

### [‚ñ§](‚ñ§.md) (Topology)
- **Position**: `‚àß` ‚áñ `[Upper Left]`
- **Duality**: `‚àß` ‚áø `[‚ç∞](‚ç∞.md)` (Logic vs. Choice)

---

## ‚Üí Reduction Rules

### Boolean Logic
```
‚ä§  ‚àß ‚ä§  ‚Üí ‚ä§
‚ä§  ‚àß ‚ä• ‚Üí ‚ä•
‚ä• ‚àß ‚ä§  ‚Üí ‚ä•
‚ä• ‚àß ‚ä• ‚Üí ‚ä•
```

### Œª-reduction
```
(Œªpq.pqp) ‚ä§ ‚ä§
‚Üí ‚ä§ ‚ä§ ‚ä§
‚Üí (Œªxy.x) ‚ä§ ‚ä§
‚Üí ‚ä§
```

---

## üé≠ Role in Composition

AND is the fundamental **aggregator** of truth.
It is used to combine predicates and conditions.

### Filter
Used in `filter` operations to combine multiple criteria.

---

## üîó –ó–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ ‚Ü£–∞–º–∏

### With [¬¨](¬¨.md)
De Morgan's Laws connect ‚àß and ‚à® (OR) via ¬¨.
`a ‚àß b = ¬¨(¬¨a ‚à® ¬¨b)`

### With ? (Selection)
AND can be implemented using Selection:
`p ‚àß q ‚â° ? p q ‚ä•`

---

## [‚ü∂](‚ü∂) –ü—Ä–æ–µ–∫—Ü—ñ—ó

### [ü¶ï](ü¶ï)
```typescript
// Projection: ./ùüè.ts
export const and = (p: boolean, q: boolean): boolean => p && q;

// Curried version (optional)
export const andC = (p: boolean) => (q: boolean) => p && q;

// Aliases
export const conjunction = and;
export const all = and;
```

### Rust (future)
```rust
pub fn and(p: bool, q: bool) -> bool { p && q }
```

---

## [‚ä¢](‚ä¢.md) (–î–æ–∫–∞–∑–∏)

### Theorem 1: Commutativity
**Statement**: `p ‚àß q = q ‚àß p`

**Proof**:
By truth table:
‚ä§ ‚ä§ -> ‚ä§ = ‚ä§
‚ä§ ‚ä• -> ‚ä• = ‚ä•
‚ä• ‚ä§ -> ‚ä• = ‚ä•
‚ä• ‚ä• -> ‚ä• = ‚ä•
‚àé

---

## üéØ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### Guard Clauses
```typescript
if (and(isValid, isReady)) {
  proceed();
}
```

### Validation
```typescript
const isValidUser = (u: User) => and(hasName(u), hasEmail(u));
```

---

## [üåå](üåå)

‚ö°Ô∏è: –ó–Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Ç–∏–Ω. –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Å–ø—ñ–ª—å–Ω—É —ñ—Å—Ç–∏–Ω—É.

### –û–Ω—Ç–æ–ª–æ–≥—ñ—è
- **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ**: –ü–æ—Ç—Ä–µ–±—É—î `Bool` (—è–∫–∏–π –≤–∏–≤–æ–¥–∏—Ç—å—Å—è –∑ `Œª`).
- **–†–µ–∑–æ–Ω–∞–Ω—Å**: 85% (Logic).
- **–ú–µ—Ç–∞—Ñ–æ—Ä–∞**: **–í—É–∑–æ–ª**. –ú—ñ—Å—Ü–µ, –¥–µ –¥–≤—ñ –Ω–∏—Ç–∫–∏ —Å—Ç–∞—é—Ç—å –∫–∞–Ω–∞—Ç–æ–º.

---

## üîó –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–ë–∞–∑–æ–≤–∏–π —à–∞—Ä (‚≠ò)](‚≠ò)
- [NOT (¬¨)](¬¨)
- [Selection (?)](?)
- [TypeScript –ø—Ä–æ–µ–∫—Ü—ñ—è](./ùüè.ts)

---

*–ü—Ä–æ—î–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—è. –Ü—Å—Ç–∏–Ω–∞ ‚Äî –æ–¥–Ω–∞.*

