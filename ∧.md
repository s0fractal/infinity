---
$: ‚àß
$type: ‚Ü£
$layer: ‚≠ò
$aliases: [and, conjunction, all, U+2227, AND, –∫–æ–Ω‚Äô—é–Ω–∫—Ü—ñ—è, allOf ‚à©]
$composition: primitive
---

# ‚àß ‚Äî AND

> *"Two paths become one truth"*  
> *"–Ñ–¥–Ω—ñ—Å—Ç—å."*

---

## ‚àà –§–æ—Ä–º–∞–ª—å–Ω–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è

### –ü–ª–∞—Ç–æ–Ω—ñ—á–Ω–∞ —Ñ–æ—Ä–º–∞ (Œª-calculus)
Defined using Church Booleans:
```haskell
TRUE  ‚â° Œªxy.x
FALSE ‚â° Œªxy.y
‚àß     ‚â° Œªpq.pqp
```
If `p` is TRUE, it returns `q` (so result depends on `q`).
If `p` is FALSE, it returns `p` (which is FALSE).

### Type signature
```haskell
‚àß :: Bool ‚Üí Bool ‚Üí Bool
```

**Church-Rosser**: Confluent.

---

## [‚äÉ](‚äÉ)

### Algebraic Properties
1. **Associative**: `(a ‚àß b) ‚àß c = a ‚àß (b ‚àß c)`
2. **Commutative**: `a ‚àß b = b ‚àß a`
3. **Idempotent**: `a ‚àß a = a`
4. **Identity Element**: `TRUE` (`a ‚àß TRUE = a`)
5. **Annihilator**: `FALSE` (`a ‚àß FALSE = FALSE`)
6. **Distributive**: Over OR (‚à®).

### [‚éç](‚éç.md)
- **[‚¶æ](‚¶æ.md)**: 1.0
- **[‚èè](‚èè.md)**: Always (O(1))
- **[‚àÆ](‚àÆ.md)**: O(1)
- **[‚òç](‚òç.md)**: 3 (‚Ü¶ 2 ‚Üí 1)

---

## üìê Hex-Torus Topology

### Visual Structure
```
      p     q
      ‚îÇ     ‚îÇ
    ‚îå‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îê
    ‚îÇ    ‚àß    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
       p ‚àß q
```

The AND morphism is a **gate**. It only allows flow if both conditions are met.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell.
- 2 inputs, 1 output.
- Convergence point.

### Sacred Geometry
```
      ¬¨
    /   \
   ‚àß     ?   ‚Üê Logic Gate (Left)
  |   I   |
   ‚äó     Œª
    \   /
      @
```
‚àß sits on the upper left, balancing Selection (`?`) on the right.
Logic vs. Choice.

---

## ‚Üí Reduction Rules

### Boolean Logic
```
TRUE  ‚àß TRUE  ‚Üí TRUE
TRUE  ‚àß FALSE ‚Üí FALSE
FALSE ‚àß TRUE  ‚Üí FALSE
FALSE ‚àß FALSE ‚Üí FALSE
```

### Œª-reduction
```
(Œªpq.pqp) TRUE TRUE
‚Üí TRUE TRUE TRUE
‚Üí (Œªxy.x) TRUE TRUE
‚Üí TRUE
```

---

## üé≠ Role in Composition

AND is the fundamental **aggregator** of truth.
It is used to combine predicates and conditions.

### Filter
Used in `filter` operations to combine multiple criteria.

---

## üîó –ó–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ ‚Ü£–∞–º–∏

### With ¬¨ (NOT)
De Morgan's Laws connect ‚àß and ‚à® (OR) via ¬¨.
`a ‚àß b = ¬¨(¬¨a ‚à® ¬¨b)`

### With ? (Selection)
AND can be implemented using Selection:
`p ‚àß q ‚â° ? p q FALSE`

---

## [‚ü∂](‚ü∂) –ü—Ä–æ–µ–∫—Ü—ñ—ó

### [ü¶ï](ü¶ï)
```typescript
// Projection: ./ùüè.ts
export const and = (p: boolean, q: boolean): boolean => p && q;

// Curried version (optional)
export const andC = (p: boolean) => (q: boolean) => p && q;

// Aliases
export const conjunction = and;
export const all = and;
```

### Rust (future)
```rust
pub fn and(p: bool, q: bool) -> bool { p && q }
```

---

## üî¨ –î–æ–∫–∞–∑–∏

### Theorem 1: Commutativity
**Statement**: `p ‚àß q = q ‚àß p`

**Proof**:
By truth table:
T T -> T = T
T F -> F = F
F T -> F = F
F F -> F = F
‚àé

---

## üéØ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### Guard Clauses
```typescript
if (and(isValid, isReady)) {
  proceed();
}
```

### Validation
```typescript
const isValidUser = (u: User) => and(hasName(u), hasEmail(u));
```

---

## üåå –§—ñ–ª–æ—Å–æ—Ñ—ñ—è

### –Ü–Ω—Ç–µ–Ω—Ü—ñ—è
–ó–Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Ç–∏–Ω. –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ —Å–ø—ñ–ª—å–Ω—É —ñ—Å—Ç–∏–Ω—É.

### –û–Ω—Ç–æ–ª–æ–≥—ñ—è
- **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ**: –ü–æ—Ç—Ä–µ–±—É—î `Bool` (—è–∫–∏–π –≤–∏–≤–æ–¥–∏—Ç—å—Å—è –∑ `Œª`).
- **–†–µ–∑–æ–Ω–∞–Ω—Å**: 85% (Logic).
- **–ú–µ—Ç–∞—Ñ–æ—Ä–∞**: **–í—É–∑–æ–ª**. –ú—ñ—Å—Ü–µ, –¥–µ –¥–≤—ñ –Ω–∏—Ç–∫–∏ —Å—Ç–∞—é—Ç—å –∫–∞–Ω–∞—Ç–æ–º.

---

## üîó –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–ë–∞–∑–æ–≤–∏–π —à–∞—Ä (‚≠ò)](‚≠ò)
- [NOT (¬¨)](¬¨)
- [Selection (?)](../?/ùüè.md)
- [TypeScript –ø—Ä–æ–µ–∫—Ü—ñ—è](./ùüè.ts)

---

*–ü—Ä–æ—î–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—è. –Ü—Å—Ç–∏–Ω–∞ ‚Äî –æ–¥–Ω–∞.*

