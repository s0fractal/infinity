---
$: Œª
$type: ‚Ü£
$layer: ‚≠ò
$aliases: [function, abstract, define]
$composition: primitive
---

# Œª ‚Äî Abstraction

> *"To abstract is to pull the essence from the chaos"*  
> *"–°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å–≤—ñ—Ç—É —á–µ—Ä–µ–∑ —Å–ª–æ–≤–æ."*

---

## [‚àà](‚àà)

### –ü–ª–∞—Ç–æ–Ω—ñ—á–Ω–∞ —Ñ–æ—Ä–º–∞ (Œª-calculus)
Abstraction is the mechanism for creating functions. It binds a variable `x` in a term `M`.
```haskell
Œªx.M
```

### Type signature
```haskell
Œª :: (Œ± ‚Üí Œ≤)
```
In type theory, it introduces the arrow type `‚Üí`.

**Church-Rosser**: N/A (It's a constructor).

---

## [‚äÉ](‚äÉ)

### [‚®ä](‚®ä)
- **[Œ±](Œ±.md)**: `Œªx.M ‚â° Œªy.M[x := y]`
- **[Œ∑](Œ∑.md)**: `Œªx.f x ‚â° f`

### [‚éç](‚éç.md)
- **[‚¶æ](‚¶æ.md)**: 1.0
- **[‚èè](‚èè.md)**: Immediate (O(1))
- **[‚àÆ](‚àÆ.md)**: Allocation of closure
- **[‚òç](‚òç.md)**: 2 (‚Ü¶ 1 ‚Üí 1)

---

## üìê Hex-Torus Topology

### Visual Structure
```
      x
      ‚îÇ
    ‚îå‚îÄ‚ñº‚îÄ‚îê
    ‚îÇ Œª ‚îÇ
    ‚îî‚îÄ‚î¨‚îÄ‚îò
      ‚îÇ
      M
```

The Abstraction morphism **encapsulates** a subgraph `M` and exposes an input port `x`.
It creates a **boundary** between the outside world and the internal logic.

### Geometric Properties
In the hexagonal tessellation:
- Occupies 1 hex cell (as the header)
- Defines a **scope** (a region of the hex grid).
- Acts as a **gateway**.

### [‚ñ§](‚ñ§.md) (Topology)
- **Position**: `Œª` ‚áò `[Lower Right]`
- **Duality**: `Œª` ‚áø `[‚äó](‚äó.md)` (Function vs. Structure / Time vs. Space)

---

## ‚Üí Reduction Rules

### Œ≤-reduction
Abstraction prepares the term for Œ≤-reduction:
```
(Œªx.M) N ‚Üí M[x := N]
```

---

## üé≠ Role in Composition

Abstraction is the **generator** of all other morphisms.
Every other morphism (except primitives) is defined using abstraction.

### Currying
```
Œªx.Œªy.M ‚â° Œªxy.M
```
Abstraction allows multi-argument functions via currying.

---

## üîó –ó–≤'—è–∑–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ [‚Ü£](‚Ü£.md)

### With[ @](@.md) (Application)
Duals. Œª builds, @ destroys (reduces).

### With ‚äó (Pairing)
Œª creates function spaces (`A ‚Üí B`).
‚äó creates product spaces (`A √ó B`).
Together they form the basis of Cartesian Closed Categories.

---

## ‚ü¶[‚ü∂](‚ü∂.md) ‚üß–ü—Ä–æ–µ–∫—Ü—ñ—ó

### TypeScript/Deno
```typescript
// Projection: ./ùüè.ts
// In JS/TS, abstraction is implicit via arrow functions.
// We provide a helper to make it explicit and type-safe.

export const lambda = <A, B>(f: (a: A) => B): (a: A) => B => f;

// Aliases
export const abstract = lambda;
export const fun = lambda;

// Usage
const double = lambda((x: number) => x * 2);
```

### Rust (future)
```rust
// Rust closures
|x| x * 2
```

---

## [‚ä¢](‚ä¢.md) (–î–æ–∫–∞–∑–∏)

### Theorem 1: Œ±-equivalence
**Statement**: `Œªx.x ‚â° Œªy.y`

**Proof**:
Renaming `x` to `y` in `x` gives `y`.
Therefore `Œªx.x` is Œ±-equivalent to `Œªy.y`.
‚àé

### Theorem 2: Œ∑-reduction
**Statement**: `Œªx.f x ‚â° f` (if x is not free in f)

**Proof**:
For any argument `a`:
`(Œªx.f x) a ‚Üí f a` (by Œ≤-reduction)
Since they behave identically for all inputs, they are equivalent.
‚àé

---

## üéØ –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è

### Defining Logic
```typescript
// Church Booleans
const ‚ä§ = lambda(t => lambda(f => t));
const ‚ä• = lambda(t => lambda(f => f));
```

### Defining Data
```typescript
// Church Numerals
const ZERO = lambda(f => lambda(x => x));
const ONE = lambda(f => lambda(x => f(x)));
```

---

## [üåå](üåå)

‚ö°Ô∏è: –í—ñ–¥–∫–ª–∞—Å—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è. –°—Ç–≤–æ—Ä–∏—Ç–∏ –ø–æ—Ç–µ–Ω—Ü—ñ–∞–ª. –í–∏–∑–Ω–∞—á–∏—Ç–∏ "—â–æ", –Ω–µ –≤–∏–∫–æ–Ω—É—é—á–∏ "–∫–æ–ª–∏".

### –û–Ω—Ç–æ–ª–æ–≥—ñ—è
- **–ó–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ**: –ñ–æ–¥–Ω–∏—Ö (–ø—Ä–∏–º—ñ—Ç–∏–≤).
- **–†–µ–∑–æ–Ω–∞–Ω—Å**: 99% (The Word).
- **–ú–µ—Ç–∞—Ñ–æ—Ä–∞**: **–ù–∞—Å—ñ–Ω–Ω—è**. –í–æ–Ω–æ –º—ñ—Å—Ç–∏—Ç—å –≤ —Å–æ–±—ñ –¥–µ—Ä–µ–≤–æ, –∞–ª–µ —â–µ –Ω–µ —î –¥–µ—Ä–µ–≤–æ–º.

---

## üîó –ü–æ—Å–∏–ª–∞–Ω–Ω—è

- [–ë–∞–∑–æ–≤–∏–π —à–∞—Ä (‚≠ò)](../ùüè.md)
- [Application (@)](../@/ùüè.md)
- [TypeScript –ø—Ä–æ–µ–∫—Ü—ñ—è](./ùüè.ts)

---

*–ü—Ä–æ—î–∫—Ü—ñ—ó –º–æ–∂—É—Ç—å –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—è. –î—É–º–∫–∞ ‚Äî –≤—ñ—á–Ω–∞.*
